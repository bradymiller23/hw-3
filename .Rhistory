diff_mean <- df %>%
select(quality, type) %>%
group_by(type) %>%
summarise(means = mean(quality))
View(diff_mean)
diff_mean <- df %>%
(mean(subset(df, df$type == 'red')$quality)) - (mean(subset(df, df$type == 'white') $quality))
?subset()
red_wine_mean <- mean(subset(df, df$type == 'red')$quality)
View(diff_mean)
diff_mean <- white_wine_mean - red_wine_mean
white_wine_mean <- mean(subset(df, df$type == 'white')$quality)
diff_mean <- white_wine_mean - red_wine_mean
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type = 'white')$quality)
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type == 'white')$quality)
nR <- length(subset(df, df$type == 'red')$quality)
varW <- var((subset(df, df$type == 'white')$quality))
varR <- var(subset(df, df$type == 'red')$quality)
sp_squared <-  ((nW - 1) * varW + (nR - 1)* varR) / (nW + nR - 2)
?t_test()
?qt()
?t.test()
t1 <-  t.test(estimate = diff_mean, stderr = sq_squared) # Insert your code here
t1 <-  t.test(estimate = diff_mean, stderr = sq_squared, data = df) # Insert your code here
t1 <-  t.test(subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, estimate = diff_mean, stderr = sq_squared) # Insert your code here
View(t1)
t1
t1 <-  t.test(subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, estimate = diff_mean, stderr = sq_squared) # Insert your code here
t1
t1 <- diff_mean/(sqrt(sp_sqaured * (1/nW + 1/nR)))
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t2 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t1 <-  t.test(subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, estimate = diff_mean, stderr = sq_squared) # Insert your code here
t1
# computing t-statistic for given mean differnce and pooled sample variance
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t_test <- t.test(subset(df, df$type == 'white')$quality), subset(df, df$type == 'red')$quality))
t_test <- t.test((subset(df, df$type == 'white')$quality), subset(df, df$type == 'red')$quality))
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality)
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t2 <- ... t_test$statistic
t2 <- t_test$statistic
fit <- lm(df$quality ~ df$type) # Insert your here
fit
fit <- lm(df$quality ~ subset(df, df$type in ('red', 'white'))$type) # Insert your here
fit <- lm(quality ~ type) # Insert your here
fit <- lm(df$quality ~ df$type) # Insert your here
t3 <- fit$coefficients # Insert your here
fit# Insert your here
t3 <- fit$(df$type) # Insert your here
t3 <- fit$coefficients$type # Insert your here
t3 <- fit$coefficients["df$type"] # Insert your here
t3
t3 <- fit$coefficients[df$type] # Insert your here
t3
t3 <- fit$coefficients[type] # Insert your here
t3 <- fit$coefficients[(df$type)] # Insert your here
t3
t3 <- fit$coefficients["(df$type)"] # Insert your here
t3
t3 <- fit$coefficients[1] # Insert your here
t3
t3 <- fit$coefficients[2] # Insert your here
t3
# changing type of 'type' to factor
df$type <- factor(type)
typeof(df$type)
# changing type of 'type' to factor
df$type <- factor(df$type)
typeof(df)
typeof(df$type)
df
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide)) %>%
factor(df$type)
url1 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv"
url2 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv"
?read.csv()
df1 <- read.csv(url1, sep = ';')
df2 <- read.csv(url2, sep = ';')
# adding the 'type' column to both the white and red wine data frames
df1 <- df1 %>%
mutate(type = 'white')
df2 <- df2 %>%
mutate(type = 'red')
# joining the two data frames on the type column
df <- df1 %>%
full_join(df2, type = type)
# changing the period in column names to underscores
colnames(df) <- gsub('\\.', '_', colnames(df))
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide)) %>%
factor(df$type)
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide))
str(df)
df$type <- factor(df$type)
str(df)
df
# adding the 'type' column to both the white and red wine data frames
df1 <- df1 %>%
mutate(type = 'white')
df2 <- df2 %>%
mutate(type = 'red')
# joining the two data frames on the type column
df <- df1 %>%
full_join(df2, type = type)
# changing the period in column names to underscores
colnames(df) <- gsub('\\.', '_', colnames(df))
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
# removing any missing values
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide)) %>%
na.omit()
# changing the type of the 'type' column
df$type <- factor(df$type)
# checking dimensions of df
dim(df)
# subsetting the data frame by type of wine (returns all rows for that wine type)
# using the mean function to find the mean of quality for each wine
red_wine_mean <- mean(subset(df, df$type == 'red')$quality)
white_wine_mean <- mean(subset(df, df$type == 'white')$quality)
# calculating the difference in mean between the 2 wine types
diff_mean <- white_wine_mean - red_wine_mean
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type == 'white')$quality)
nR <- length(subset(df, df$type == 'red')$quality)
varW <- var((subset(df, df$type == 'white')$quality))
varR <- var(subset(df, df$type == 'red')$quality)
sp_squared <- ((nW - 1) * varW + (nR - 1)* varR) / (nW + nR - 2)
# computing t-statistic for given mean differnce and pooled sample variance
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t2 <- t_test$statistic
fit <- lm(df$quality ~ df$type)
fit# Insert your here
t3 <- fit$coefficients[2]
c(t1, t2, t3)
# subsetting the data frame by type of wine (returns all rows for that wine type)
# using the mean function to find the mean of quality for each wine
red_wine_mean <- mean(subset(df, df$type == 'red')$quality)
white_wine_mean <- mean(subset(df, df$type == 'white')$quality)
# calculating the difference in mean between the 2 wine types
diff_mean <- white_wine_mean - red_wine_mean
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type == 'white')$quality)
nR <- length(subset(df, df$type == 'red')$quality)
varW <- var((subset(df, df$type == 'white')$quality))
varR <- var(subset(df, df$type == 'red')$quality)
sp_squared <- ((nW - 1) * varW + (nR - 1)* varR) / (nW + nR - 2)
# computing t-statistic for given mean differnce and pooled sample variance
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t2 <- t_test$statistic
fit <- lm(df$quality ~ df$type)
fit
t3 <- fit$coefficients[2]
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t_test
model <- lm(quality ~ ., df)
summary(model) %>%
broom::tidy()
model %>%
broom::tidy()
summary(model) %>%
broom::tidy()
model_citric <- lm(quality ~ citric_acid)
model_citric <- lm(quality ~ citric_acid, df)
model_citric
summary(model_citric) %>%
broom::tidy()
model_sulfur <- lm(quality ~ total_sulfur_dioxide, df)
summary(model) %>%
broom::tidy()
summary(model_sulfur) %>%
broom::tidy()
View(df)
library(corrplot)
install.packages('corrplot')
library(corrplot)
library(corrplot)
df %>%
keep(is.numeric) %>%
cor() %>%
corrplot(R, type = 'upper', order = 'hclust')
library(readr)
library(tidyr)
library(dplyr)
library(purrr)
library(car)
library(glmnet)
url1 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv"
url2 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv"
df1 <- read.csv(url1, sep = ';')
df2 <- read.csv(url2, sep = ';')
# adding the 'type' column to both the white and red wine data frames
df1 <- df1 %>%
mutate(type = 'white')
df2 <- df2 %>%
mutate(type = 'red')
# joining the two data frames on the type column
df <- df1 %>%
full_join(df2, type = type)
# changing the period in column names to underscores
colnames(df) <- gsub('\\.', '_', colnames(df))
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
# removing any missing values
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide)) %>%
na.omit()
# changing the type of the 'type' column
df$type <- factor(df$type)
# checking dimensions of df
dim(df)
# subsetting the data frame by type of wine (returns all rows for that wine type)
# using the mean function to find the mean of quality for each wine
red_wine_mean <- mean(subset(df, df$type == 'red')$quality)
white_wine_mean <- mean(subset(df, df$type == 'white')$quality)
# calculating the difference in mean between the 2 wine types
diff_mean <- white_wine_mean - red_wine_mean
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type == 'white')$quality)
nR <- length(subset(df, df$type == 'red')$quality)
varW <- var((subset(df, df$type == 'white')$quality))
varR <- var(subset(df, df$type == 'red')$quality)
sp_squared <- ((nW - 1) * varW + (nR - 1)* varR) / (nW + nR - 2)
# computing t-statistic for given mean differnce and pooled sample variance
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t2 <- t_test$statistic
fit <- lm(df$quality ~ df$type)
fit
t3 <- fit$coefficients[2]
c(t1, t2, t3)
model <- lm(quality ~ ., df)
summary(model) %>%
broom::tidy()
model_citric <- lm(quality ~ citric_acid, df)
summary(model_citric) %>%
broom::tidy()
model_sulfur <- lm(quality ~ total_sulfur_dioxide, df)
summary(model_sulfur) %>%
broom::tidy()
library(corrplot)
df %>%
keep(is.numeric) %>%
cor() %>%
corrplot(R, type = 'upper', order = 'hclust')
library(corrplot)
df %>%
keep(is.numeric) %>%
cor() %>%
corrplot(df, type = 'upper', order = 'hclust')
library(corrplot)
df %>%
keep(is.numeric) %>%
corrplot(df, type = 'upper', order = 'hclust')
dfCorr <- df %>%
keep(is.numeric) %>%
cor()
corrplot(dfCorr, type = 'upper', order = 'hclust')
vif_model <- lm(quality ~ ., df)
vif(vif_model) %>% knitr::kable()
library(corrplot)
dfCorr <- df %>%
keep(is.numeric) %>%
cor()
corrplot(dfCorr, type = 'upper', order = 'hclust')
vif_model <- lm(quality ~ ., df)
vif(vif_model) %>% knitr::kable()
full_model <- lm(quality ~ ., df)
vif(full_model) %>% knitr::kable()
backward_formula <- formula(step(full_model, direction = 'backward', scope = formula(null_model)))
vif_model <- lm(quality ~ ., df)
vif(vif_model) %>% knitr::kable()
null_model <- lm(quality ~ 1, df)
full_model <- lm(quality ~ ., df)
backward_formula <- formula(step(full_model, direction = 'backward', scope = formula(null_model)))
backward_formula
forward_formula <- formula(step(null_model, direction = 'forward', scope = formula(full_model)))
forward_formula
y <- df$quality
make_model_matrix <- function(formula){
X <- model.matrix(rsq_formula, df)[, -1]
cnames <- colnames(X)
for(i in 1:ncol(X)){
if(!cnames[i] == "typewhite"){
X[, i] <- scale(X[, i])
} else {
colnames(X)[i] <- "type"
}
}
return(X)
}
make_model_matrix(full_model)
make_model_matrix(forward_formula)
make_model_matrix <- function(formula){
X <- model.matrix(full_model, df)[, -1]
cnames <- colnames(X)
for(i in 1:ncol(X)){
if(!cnames[i] == "typewhite"){
X[, i] <- scale(X[, i])
} else {
colnames(X)[i] <- "type"
}
}
return(X)
}
make_model_matrix(forward_formula)
?cv.glmnet()
X
lasso <- cv.glmnet(x = X, y = y, alpha = 1)
lasso <- cv.glmnet(x = make_model_formula(forward_formula), y = y, alpha = 1)
lasso <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 1)
lasso
ridgeReg <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 0)
ridgeReg
par(mfrow=c(1, 2))
plot(lassoReg)
# making a y vector that contains quality variable
y <- df$quality
# creating a design matrix for the full_model
make_model_matrix <- function(formula){
X <- model.matrix(full_model, df)[, -1]
cnames <- colnames(X)
for(i in 1:ncol(X)){
if(!cnames[i] == "typewhite"){
X[, i] <- scale(X[, i])
} else {
colnames(X)[i] <- "type"
}
}
return(X)
}
# performing lasso and ridge regression
lassoReg <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 1)
lassoReg
ridgeReg <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 0)
ridgeReg
par(mfrow=c(1, 2))
plot(lassoReg)
plot(ridgeReg)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression")
plot(ridgeReg, main = "Ridge Regression")
?plot()
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression", line = 1)
plot(ridgeReg, main = "Ridge Regression", line = 1)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression", line = 3)
plot(ridgeReg, main = "Ridge Regression", line = 3)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression", line = 2)
plot(ridgeReg, main = "Ridge Regression", line = 2)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression", line = 0)
plot(ridgeReg, main = "Ridge Regression", line = 0)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression", line = 0)
plot(ridgeReg, main = "Ridge Regression", line = 0)
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression")
plot(ridgeReg, main = "Ridge Regression")
lasso_coef <- coef(lasso, s = "lambda.1se")
# can do lambda.1se to choose different lambda that will result in diff amount of variables chosen
selected_vars <- rownames(lasso_coef)[which(abs(lasso_coef) > 0)][-1] # exclude the intercept term
lasso_coef <- coef(lasso, s = "lambda.1se")
# can do lambda.1se to choose different lambda that will result in diff amount of variables chosen
selected_vars <- rownames(lasso_coef)[which(abs(lasso_coef) > 0)][-1] # exclude the intercept term
lasso_coef
```
sessionInfo()
lasso_coef <- coef(lasso, s = "lambda.1se")
View(lasso_coef)
lasso_coef <- coef(lassoReg, s = "lambda.1se")
library(readr)
library(tidyr)
library(dplyr)
library(purrr)
library(car)
library(glmnet)
url1 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv"
url2 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv"
df1 <- read.csv(url1, sep = ';')
df2 <- read.csv(url2, sep = ';')
# adding the 'type' column to both the white and red wine data frames
df1 <- df1 %>%
mutate(type = 'white')
df2 <- df2 %>%
mutate(type = 'red')
# joining the two data frames on the type column
df <- df1 %>%
full_join(df2, type = type)
# changing the period in column names to underscores
colnames(df) <- gsub('\\.', '_', colnames(df))
# selecting all other columns beside fixed_acidity & free_sulfur_dioxide
# removing any missing values
df <- df %>%
select(-c(fixed_acidity, free_sulfur_dioxide)) %>%
na.omit()
# changing the type of the 'type' column
df$type <- factor(df$type)
# checking dimensions of df
dim(df)
# subsetting the data frame by type of wine (returns all rows for that wine type)
# using the mean function to find the mean of quality for each wine
red_wine_mean <- mean(subset(df, df$type == 'red')$quality)
white_wine_mean <- mean(subset(df, df$type == 'white')$quality)
# calculating the difference in mean between the 2 wine types
diff_mean <- white_wine_mean - red_wine_mean
# calculating the length and variance for quality for both wine types
nW <- length(subset(df, df$type == 'white')$quality)
nR <- length(subset(df, df$type == 'red')$quality)
varW <- var((subset(df, df$type == 'white')$quality))
varR <- var(subset(df, df$type == 'red')$quality)
sp_squared <- ((nW - 1) * varW + (nR - 1)* varR) / (nW + nR - 2)
# computing t-statistic for given mean differnce and pooled sample variance
t1 <- diff_mean/(sqrt(sp_squared * (1/nW + 1/nR)))
t_test <- t.test( subset(df, df$type == 'white')$quality, subset(df, df$type == 'red')$quality, var.equal = TRUE)
t2 <- t_test$statistic
fit <- lm(df$quality ~ df$type)
fit
t3 <- fit$coefficients[2]
c(t1, t2, t3)
model <- lm(quality ~ ., df)
summary(model) %>%
broom::tidy()
model_citric <- lm(quality ~ citric_acid, df)
summary(model_citric) %>%
broom::tidy()
model_sulfur <- lm(quality ~ total_sulfur_dioxide, df)
summary(model_sulfur) %>%
broom::tidy()
library(corrplot)
dfCorr <- df %>%
keep(is.numeric) %>%
cor()
corrplot(dfCorr, type = 'upper', order = 'hclust')
vif_model <- lm(quality ~ ., df)
vif(vif_model) %>% knitr::kable()
null_model <- lm(quality ~ 1, df)
full_model <- lm(quality ~ ., df)
backward_formula <- formula(step(full_model, direction = 'backward', scope = formula(null_model)))
backward_formula
forward_formula <- formula(step(null_model, direction = 'forward', scope = formula(full_model)))
forward_formula
# making a y vector that contains quality variable
y <- df$quality
# creating a design matrix for the full_model
make_model_matrix <- function(formula){
X <- model.matrix(full_model, df)[, -1]
cnames <- colnames(X)
for(i in 1:ncol(X)){
if(!cnames[i] == "typewhite"){
X[, i] <- scale(X[, i])
} else {
colnames(X)[i] <- "type"
}
}
return(X)
}
# performing lasso and ridge regression
lassoReg <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 1)
lassoReg
ridgeReg <- cv.glmnet(x = make_model_matrix(forward_formula), y = y, alpha = 0)
ridgeReg
par(mfrow=c(1, 2))
plot(lassoReg, main = "Lasso Regression")
plot(ridgeReg, main = "Ridge Regression")
lasso_coef <- coef(lassoReg, s = "lambda.1se")
# can do lambda.1se to choose different lambda that will result in diff amount of variables chosen
selected_vars <- rownames(lasso_coef)[which(abs(lasso_coef) > 0)][-1] # exclude the intercept term
selected_vars
```
lasso_coef
selected_vars
lasso_coef <- coef(lassoReg, s = "lambda.1se")
# can do lambda.1se to choose different lambda that will result in diff amount of variables chosen
lasso_vars <- rownames(lasso_coef)[which(abs(lasso_coef) > 0)][-1] # exclude the intercept term
make_formula <- function(x){
as.formula(
paste("quality ~ ", paste(x, collapse = " + "))
)
}
lasso_formula <- make_formula(lasso_vars)
lasso_formula
lasso_coef <- coef(lassoReg, s = "lambda.1se")
lasso_coef
lasso_vars <- rownames(lasso_coef)[which(abs(lasso_coef) > 0)][-1]
make_formula <- function(x){
as.formula(
paste("quality ~ ", paste(x, collapse = " + "))
)
}
lasso_formula <- make_formula(lasso_vars)
ridge_coef <- coef(ridgeReg, s = "lambda.1se")
ridge_coef
ridge_vars <- rownames(ridge_coef)[which(abs(ridge_coef) > 0)][-1]
make_formula <- function(x){
as.formula(
paste("quality ~ ", paste(x, collapse = " + "))
)
}
ridge_formula <- make_formula(ridge_vars)
ridge_formula
x_vars <- colnames(df %>% select(-quality))
